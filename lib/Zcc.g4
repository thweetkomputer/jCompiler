grammar Zcc;

IF: 'if';
ELSE: 'else';
VOID: 'void';
INT: 'int';
RETURN: 'return';
WHILE: 'while';
BREAK: 'break';
CONTINUE: 'continue';
CONST: 'const';
IDENT: [_a-zA-Z] [_a-zA-Z0-9]*;
DECIMAL_CONST: [1-9] [0-9]*;
OCTAL_CONST: '0' [0-7]*;
HEXADECIMAL_CONST: ('0x' | '0X') [0-9a-zA-F]+;
WHITE_SPACE: [ \t\r\n] -> skip;
ADD: '+';
SUB: '-';
MUL: '*';
DIV: '/';
MOD: '%';
NOT: '!';
LPAREN: '(';
RPAREN: ')';
LBRACE: '{';
RBRACE: '}';
LBRACK: '[';
RBRACK: ']';

GE: '>=';
LE: '<=';
GT: '>';
LT: '<';
COMMA: ',';
SEMECOLON: ';';
EQ: '==';
NE: '!=';
AND: '&&';
OR: '||';
ASSIGN: '=';

ident: IDENT;
number: DECIMAL_CONST | OCTAL_CONST | HEXADECIMAL_CONST;
compUnit: (decl | funcDef)*;
decl: constDecl | varDecl;
constDecl: CONST bType constDef ( COMMA constDef )* SEMECOLON;
bType: INT;
constDef: ident (LBRACK constExp RBRACK)* ASSIGN constInitVal;
constInitVal: constExp | LBRACE (constInitVal (COMMA constInitVal)*)? RBRACE;
constExp: addExp;
varDef: ident (LBRACK constExp RBRACK)* | ident (LBRACK constExp RBRACK)* ASSIGN initVal;
varDecl: bType varDef ( COMMA varDef )* SEMECOLON;
cond: lOrExp;
initVal: exp | LBRACE (initVal (COMMA initVal) *)? RBRACE;
funcDef: funcType ident LPAREN funcFParams? RPAREN block;
funcType: INT | VOID;
funcFParams: funcFParam (COMMA funcFParam) *;
funcFParam: bType ident LBRACK RBRACK (LBRACK exp RBRACK) * | bType ident;
block: LBRACE blockItem* RBRACE;
blockItem: decl | stmt;
stmt: lVal ASSIGN exp SEMECOLON | exp? SEMECOLON | RETURN exp SEMECOLON | IF LPAREN cond RPAREN stmt (ELSE stmt) ? | block |
 WHILE LPAREN cond RPAREN stmt | BREAK SEMECOLON | CONTINUE SEMECOLON | RETURN exp ? SEMECOLON;
exp: addExp;
lVal: ident (LBRACK exp RBRACK)*;
primaryExp: LPAREN exp RPAREN | lVal | number;
addExp: mulExp ( unaryOp mulExp ) *;
mulExp: unaryExp  ( pUnayOp unaryExp ) *;
relExp: addExp (cmpOp addExp) *;
eqExp: relExp (eOp relExp) *;
lAndExp: eqExp (AND eqExp) *;
lOrExp: lAndExp (OR lAndExp) *;
unaryExp: primaryExp | ident LPAREN funcRParams? RPAREN | unaryOp unaryExp;
unaryOp: ADD | SUB | NOT;
pUnayOp: MUL | DIV | MOD;
cmpOp: LT | GT | LE | GE;
eOp: EQ | NE;
funcRParams: exp ( COMMA exp )*;
