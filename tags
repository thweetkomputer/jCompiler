!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BREAK	lab3.c	/^  IF, ELSE, WHILE, BREAK, CONTINUE, RETURN,$/;"	e	enum:symbol	file:
CONST	lab3.c	/^  CONST,$/;"	e	enum:symbol	file:
CONTINUE	lab3.c	/^  IF, ELSE, WHILE, BREAK, CONTINUE, RETURN,$/;"	e	enum:symbol	file:
DECIMAL_CONST	lab3.c	/^  DECIMAL_CONST,$/;"	e	enum:symbol	file:
ELSE	lab3.c	/^  IF, ELSE, WHILE, BREAK, CONTINUE, RETURN,$/;"	e	enum:symbol	file:
EOFF	lab3.c	/^  EOFF,$/;"	e	enum:symbol	file:
FUNC_TYPE	lab3.c	/^  FUNC_TYPE, \/* int, void *\/$/;"	e	enum:symbol	file:
HEXADECIMAL_CONST	lab3.c	/^  HEXADECIMAL_CONST,$/;"	e	enum:symbol	file:
IDENT	lab3.c	/^  IDENT,$/;"	e	enum:symbol	file:
IF	lab3.c	/^  IF, ELSE, WHILE, BREAK, CONTINUE, RETURN,$/;"	e	enum:symbol	file:
MARK	lab3.c	/^  MARK, \/* [ ] ( ) { } ; ... *\/$/;"	e	enum:symbol	file:
OCTAL_CONST	lab3.c	/^  OCTAL_CONST,$/;"	e	enum:symbol	file:
RETURN	lab3.c	/^  IF, ELSE, WHILE, BREAK, CONTINUE, RETURN,$/;"	e	enum:symbol	file:
UNARY_OP	lab3.c	/^  UNARY_OP$/;"	e	enum:symbol	file:
WHILE	lab3.c	/^  IF, ELSE, WHILE, BREAK, CONTINUE, RETURN,$/;"	e	enum:symbol	file:
_getchar	lab3.c	/^void _getchar ()$/;"	f
a	cal.py	/^a = eval(sys.argv[2].replace('\/', '\/\/'))$/;"	v
c	lexical.h	/^  union {char c; int n;} val;$/;"	m	union:on::__anon1
cat_token	lab3.c	/^void cat_token (char ch)$/;"	f
ch	lab3.c	/^int ch;$/;"	v
clear_token	lab3.c	/^void clear_token ()$/;"	f
content	lab3.c	/^  char *content;$/;"	m	struct:function	file:
double_token	lab3.c	/^void double_token ()$/;"	f
error	lab3.c	/^void error (char *s)$/;"	f
flag	lab3.c	/^int flag;$/;"	v
func_type	lab3.c	/^  char *func_type;$/;"	m	struct:function	file:
function	lab3.c	/^struct function$/;"	s	file:
getsym	lab3.c	/^getsym()$/;"	f
is_empty	lexical.c	/^int is_empty(char ch)$/;"	f
is_hexadecimal_digit	lexical.c	/^int is_hexadecimal_digit (char ch)$/;"	f
is_nondigit	lexical.c	/^int is_nondigit (char ch)$/;"	f
is_nonzero_digit	lexical.c	/^int is_nonzero_digit (char ch)$/;"	f
is_num	lexical.h	/^  int is_num;$/;"	m	struct:on
is_octal_digit	lexical.c	/^int is_octal_digit (char ch)$/;"	f
is_unary_op	lexical.c	/^int is_unary_op(char ch)$/;"	f
main	lab3.c	/^int main (int argc, char *argv[])$/;"	f
main	test.c	/^int main() {$/;"	f
n	lexical.h	/^  union {char c; int n;} val;$/;"	m	union:on::__anon1
name	lab3.c	/^  char *name;$/;"	m	struct:function	file:
number	lab3.c	/^int number;$/;"	v
on	lexical.h	/^struct on$/;"	s
op_cmp	lab3.c	/^op_cmp(struct on s1, struct on s2)$/;"	f
parse_add_exp	lab3.c	/^parse_add_exp()$/;"	f
parse_block	lab3.c	/^void parse_block (char **content) $/;"	f
parse_break	lab3.c	/^int parse_break ()$/;"	f
parse_comp_unit	lab3.c	/^void parse_comp_unit (struct function * func)$/;"	f
parse_continue	lab3.c	/^int parse_continue ()$/;"	f
parse_else	lab3.c	/^int parse_else ()$/;"	f
parse_exp	lab3.c	/^parse_exp() {$/;"	f
parse_func_def	lab3.c	/^void parse_func_def (struct function * func)$/;"	f
parse_func_type	lab3.c	/^int parse_func_type ()$/;"	f
parse_if	lab3.c	/^int parse_if ()$/;"	f
parse_mul_exp	lab3.c	/^parse_mul_exp()$/;"	f
parse_number	lab3.c	/^void parse_number ()$/;"	f
parse_primary_exp	lab3.c	/^parse_primary_exp()$/;"	f
parse_return	lab3.c	/^int parse_return ()$/;"	f
parse_stmt	lab3.c	/^void parse_stmt (char **content)$/;"	f
parse_unary_exp	lab3.c	/^parse_unary_exp()$/;"	f
parse_while	lab3.c	/^int parse_while ()$/;"	f
print_num_and_op	lab3.c	/^print_num_and_op()$/;"	f
return_type	lab3.c	/^  char *return_type;$/;"	m	struct:function	file:
sp	lab3.c	/^int sp = 1;$/;"	v
stack	lab3.c	/^struct on stack[100];$/;"	v	typeref:struct:on
stack_add_char	lab3.c	/^stack_add_char(char c)$/;"	f
stack_add_int	lab3.c	/^stack_add_int(int i)$/;"	f
symbol	lab3.c	/^enum symbol symbol;$/;"	v	typeref:enum:symbol
symbol	lab3.c	/^enum symbol$/;"	g	file:
token	lab3.c	/^char *token;$/;"	v
token_capacity	lab3.c	/^int token_capacity;$/;"	v
token_length	lab3.c	/^int token_length;$/;"	v
val	lexical.h	/^  union {char c; int n;} val;$/;"	m	struct:on	typeref:union:on::__anon1
vn	lab3.c	/^int vn;$/;"	v
